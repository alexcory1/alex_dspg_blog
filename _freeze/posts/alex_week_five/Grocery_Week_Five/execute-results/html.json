{
  "hash": "162fb8bcf5dae8dc36c20729c1a5de67",
  "result": {
    "markdown": "---\ntitle: \"Grocery Team Week Five Wrap Up\"\nauthor: \"Alex Cory\"\ndate: \"2023-06-15\"\ncategories: [\"Week Five\", \"Grocery Team\"]\n---\n\n\n# Voronoi Diagrams\n\n![](images/440px-Voronoi_growth_euclidean.gif)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spatial_results, aes(lat, lng)) +\n  stat_voronoi(geom = \"path\") +\n  geom_point(mapping = aes(lat, lng))\n```\n\n::: {.cell-output-display}\n![](Grocery_Week_Five_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n# Determining Market Size\n\nWe looked into the economic methods for evaluating market size. Two metrics we looked into were Reilly's Law of Gravitation and Trade Area Capture. Reilly's law is based on the idea people will tend to shop in areas with a higher population, and the model is based on a ratio between distance and population. Trade area capture uses historical data and income in areas to give a prediction of actual numbers of people who shop in an area.\n\n# Aaron\n\nThis week Aaron worked on creating a function that takes latitude and longitude as inputs and outputs the corresponding Census geographies. So far, we have two: one that's simple and one that is more complex. We are currently working on adjusting them and improving their performance, as well as figuring out how this function fits into the full patchwork of functions for our tool.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_census_geos <- function(longitude, latitude) {\n  \n  API_KEY <- Sys.getenv(\"GOOGLE_KEY\")\n  \n  address <- revgeo::revgeo(longitude = longitude, latitude = latitude, \n                            provider = 'google', output = \"frame\",\n                            API = API_KEY)\n  \n  city <- address$city\n  \n  state <- address$state\n  \n  state_ab <- state.abb[match(state,state.name)]\n\n  \n  # set options\n  options(tigris_class = \"sf\") # use sf objects\n  \n  options(tigris_use_cache = TRUE) # cache downloaded files\n  \n  # get shapefiles for places in state\n  places <- tigris::places(state = state_ab, cb = TRUE)\n  \n  # get shapefiles for counties in state\n  counties <- tigris::counties(state = state_ab, cb = TRUE)\n  \n  # join places with counties with st_join\n  city_county <- sf::st_join(places, counties, join = sf::st_within)\n  \n  # filter places by city name\n  city_county_frame <- city_county |> dplyr::filter(NAME.x == city) |> dplyr::select(NAMELSAD.y)\n  \n  county <- city_county_frame$NAMELSAD.y[1]\n  \n\n  # county passed to TidyCensus\n  \n  census <- tidycensus::get_decennial(\n    geography = \"block\", \n    variables = \"P2_002N\",\n    county = county,\n    state = state_ab,\n    year = 2020,\n    geometry = TRUE)\n  \n  \n  census\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nblock_table <- get_census_geos(-93, 42)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Getting geocode data from Google: https://maps.googleapis.com/maps/api/geocode/json?latlng=42,-93&key=AIzaSyDvqKryLr-X0TNlHJXkRz3536gBSM2dGco\"\n```\n:::\n\n```{.r .cell-code}\nknitr::kable(block_table[1:5,] )\n```\n\n::: {.cell-output-display}\n|GEOID           |NAME                                                                |variable | value|geometry                       |\n|:---------------|:-------------------------------------------------------------------|:--------|-----:|:------------------------------|\n|191279503001019 |Block 1019, Block Group 1, Census Tract 9503, Marshall County, Iowa |P2_002N  |     0|POLYGON ((-93.029 42.02367,... |\n|191279502002006 |Block 2006, Block Group 2, Census Tract 9502, Marshall County, Iowa |P2_002N  |     0|POLYGON ((-93.11787 42.2077... |\n|191279501002009 |Block 2009, Block Group 2, Census Tract 9501, Marshall County, Iowa |P2_002N  |     0|POLYGON ((-93.04905 42.1297... |\n|191279502002135 |Block 2135, Block Group 2, Census Tract 9502, Marshall County, Iowa |P2_002N  |     0|POLYGON ((-93.13204 42.1058... |\n|191279503004007 |Block 4007, Block Group 4, Census Tract 9503, Marshall County, Iowa |P2_002N  |     0|POLYGON ((-92.98028 41.9495... |\n:::\n:::\n\n\n\n# Srika\n\n# Harun\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplaces_multiloc_pull <- function(df, name = NULL, \n                                 search_string = NULL, \n                                 keyword = NULL, \n                                 lat = c(df[,2]),\n                                 lng = df[,3],\n                                 radius = 6500, \n                                 type = NULL, \n                                 api_key = Sys.getenv(\"PLACES_KEY\"), \n                                 place_type = NULL) {\n  \n  result_list <- list()\n  \n  for (i in 1:dim(test_cities)[1]) {\n    \n    start_time <- Sys.time()\n    \n    string <- sprintf(\"df_%f\", i)\n    \n    spring <- noquote(string) \n    \n    spring <- googleway::google_places(search_string = search_string, \n                                   name = name, \n                                   location = c(lat[i], lng[i]), \n                                   radius = radius, \n                                   keyword = keyword, \n                                   key = api_key)\n    \n    \n    Sys.sleep(2)\n    \n    result_list <- append(result_list, list(spring$results))\n    \n    end_time <- Sys.time()\n    total_time <- end_time - start_time\n    print(sprintf(\"Execution time for iteration %d is %.2f\", i, total_time))\n  }\n  \n  return(result_list)\n  \n}\n```\n:::\n",
    "supporting": [
      "Grocery_Week_Five_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}